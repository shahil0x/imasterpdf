import os
import io
import zipfile
import tempfile
import uuid
from datetime import datetime
from pathlib import Path

from flask import Flask, request, render_template, send_file, jsonify, redirect, url_for, Response
from werkzeug.utils import secure_filename
from PyPDF2 import PdfReader, PdfWriter, PdfMerger
from docx import Document
from reportlab.lib.pagesizes import letter, A4
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch, cm
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image as ReportLabImage
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT
from pdfminer.high_level import extract_text
from pdfminer.layout import LAParams
from PIL import Image
import concurrent.futures

app = Flask(__name__)
app.config['SECRET_KEY'] = os.urandom(24)
app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50 MB max file size
app.config['UPLOAD_FOLDER'] = tempfile.gettempdir()
app.config['ALLOWED_EXTENSIONS'] = {
    'pdf': ['pdf'],
    'word': ['doc', 'docx'],
    'images': ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp', 'tif']
}

def allowed_file(filename, file_type='pdf'):
    """Check if file extension is allowed"""
    if '.' not in filename:
        return False
    ext = filename.rsplit('.', 1)[1].lower()
    return ext in app.config['ALLOWED_EXTENSIONS'].get(file_type, [])

def cleanup_file(filepath):
    """Safely remove temporary file"""
    try:
        if os.path.exists(filepath):
            os.remove(filepath)
    except:
        pass

def generate_unique_filename(original_name, extension):
    """Generate unique filename with original name prefix"""
    unique_id = str(uuid.uuid4())[:8]
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    original_base = Path(original_name).stem[:50]  # Get filename without extension, limit length
    return f"{original_base}_{timestamp}_{unique_id}.{extension}"

def validate_file_size(file):
    """Validate file size"""
    file.seek(0, os.SEEK_END)
    size = file.tell()
    file.seek(0)
    
    if size < 1024:  # 1 KB minimum
        return False, "File is too small (minimum 1 KB)"
    if size > app.config['MAX_CONTENT_LENGTH']:
        return False, f"File exceeds maximum size of 50 MB"
    return True, ""

# ==================== PDF TOOLS ====================

@app.route('/api/pdf-to-word', methods=['POST'])
def pdf_to_word():
    """Convert PDF to Word document"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    if not allowed_file(file.filename, 'pdf'):
        return jsonify({'error': 'Invalid file type. Only PDF files are allowed.'}), 400
    
    # Validate file size
    is_valid, error_msg = validate_file_size(file)
    if not is_valid:
        return jsonify({'error': error_msg}), 400
    
    try:
        # Save uploaded file
        input_filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], input_filename)
        file.save(input_path)
        
        # Extract text from PDF using pdfminer with better layout preservation
        laparams = LAParams()
        text = extract_text(input_path, laparams=laparams)
        
        # Create Word document
        doc = Document()
        
        # Split text into paragraphs and add to document
        paragraphs = text.split('\n\n')
        for para in paragraphs:
            if para.strip():
                doc.add_paragraph(para.strip())
        
        # Save to bytes buffer
        output_buffer = io.BytesIO()
        doc.save(output_buffer)
        output_buffer.seek(0)
        
        # Cleanup
        cleanup_file(input_path)
        
        output_filename = generate_unique_filename(file.filename, 'docx')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        )
        
    except Exception as e:
        return jsonify({'error': f'Conversion failed: {str(e)}'}), 500

@app.route('/api/merge-pdf', methods=['POST'])
def merge_pdf():
    """Merge multiple PDF files into one"""
    if 'files' not in request.files:
        return jsonify({'error': 'No files uploaded'}), 400
    
    files = request.files.getlist('files')
    valid_files = [f for f in files if f.filename != '']
    
    if len(valid_files) < 2:
        return jsonify({'error': 'Please upload at least 2 PDF files'}), 400
    
    if len(valid_files) > 20:
        return jsonify({'error': 'Maximum 20 files allowed'}), 400
    
    try:
        merger = PdfMerger()
        temp_files = []
        
        for file in valid_files:
            if not allowed_file(file.filename, 'pdf'):
                return jsonify({'error': 'Invalid file type. Only PDF files are allowed.'}), 400
            
            # Validate file size
            is_valid, error_msg = validate_file_size(file)
            if not is_valid:
                # Cleanup temp files before returning error
                for temp_file in temp_files:
                    cleanup_file(temp_file)
                return jsonify({'error': error_msg}), 400
            
            # Save each file temporarily
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(filepath)
            temp_files.append(filepath)
            
            # Add to merger
            merger.append(filepath)
        
        # Create merged PDF
        output_buffer = io.BytesIO()
        merger.write(output_buffer)
        merger.close()
        output_buffer.seek(0)
        
        # Cleanup temporary files
        for filepath in temp_files:
            cleanup_file(filepath)
        
        output_filename = generate_unique_filename("merged", 'pdf')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        # Cleanup temp files on error
        if 'temp_files' in locals():
            for filepath in temp_files:
                cleanup_file(filepath)
        return jsonify({'error': f'Merge failed: {str(e)}'}), 500

@app.route('/api/rotate-pdf', methods=['POST'])
def rotate_pdf():
    """Rotate PDF pages"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    
    # Get form data with defaults
    try:
        angle = int(request.form.get('angle', 90))
    except ValueError:
        angle = 90
    
    rotate_all = request.form.get('rotate_all', 'true').lower() == 'true'
    
    if not allowed_file(file.filename, 'pdf'):
        return jsonify({'error': 'Invalid file type. Only PDF files are allowed.'}), 400
    
    # Validate file size
    is_valid, error_msg = validate_file_size(file)
    if not is_valid:
        return jsonify({'error': error_msg}), 400
    
    try:
        # Save uploaded file
        input_filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], input_filename)
        file.save(input_path)
        
        reader = PdfReader(input_path)
        writer = PdfWriter()
        
        # Validate angle
        if angle not in [90, 180, 270]:
            angle = 90
        
        # Rotate pages
        for i, page in enumerate(reader.pages):
            if rotate_all or i == 0:  # Rotate all pages or just first page
                page.rotate(angle)
            writer.add_page(page)
        
        # Create output PDF
        output_buffer = io.BytesIO()
        writer.write(output_buffer)
        output_buffer.seek(0)
        
        # Cleanup
        cleanup_file(input_path)
        
        output_filename = generate_unique_filename(file.filename, 'pdf')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        return jsonify({'error': f'Rotation failed: {str(e)}'}), 500

@app.route('/api/delete-pages', methods=['POST'])
def delete_pages_pdf():
    """Delete selected pages from PDF"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    pages_input = request.form.get('pages', '').strip()
    
    if not allowed_file(file.filename, 'pdf'):
        return jsonify({'error': 'Invalid file type. Only PDF files are allowed.'}), 400
    
    if not pages_input:
        return jsonify({'error': 'Please specify pages to delete'}), 400
    
    # Validate file size
    is_valid, error_msg = validate_file_size(file)
    if not is_valid:
        return jsonify({'error': error_msg}), 400
    
    try:
        # Parse pages input (e.g., "1,3,5" or "2-4" or "1,3-5")
        pages_to_delete = set()
        for part in pages_input.split(','):
            part = part.strip()
            if not part:
                continue
                
            if '-' in part:
                try:
                    start, end = map(int, part.split('-'))
                    if start > end:
                        start, end = end, start
                    pages_to_delete.update(range(start, end + 1))
                except ValueError:
                    return jsonify({'error': f'Invalid range format: {part}'}), 400
            else:
                try:
                    pages_to_delete.add(int(part))
                except ValueError:
                    return jsonify({'error': f'Invalid page number: {part}'}), 400
        
        if not pages_to_delete:
            return jsonify({'error': 'No valid pages specified'}), 400
        
        # Save uploaded file
        input_filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], input_filename)
        file.save(input_path)
        
        reader = PdfReader(input_path)
        total_pages = len(reader.pages)
        
        # Validate page numbers
        for page_num in pages_to_delete:
            if page_num < 1 or page_num > total_pages:
                return jsonify({'error': f'Page {page_num} is out of range (1-{total_pages})'}), 400
        
        # Convert to 0-based indexing
        pages_to_delete = {p - 1 for p in pages_to_delete}
        
        writer = PdfWriter()
        
        # Add all pages except those to delete
        for i, page in enumerate(reader.pages):
            if i not in pages_to_delete:
                writer.add_page(page)
        
        # Check if any pages remain
        if len(writer.pages) == 0:
            cleanup_file(input_path)
            return jsonify({'error': 'All pages would be deleted. Operation cancelled.'}), 400
        
        # Create output PDF
        output_buffer = io.BytesIO()
        writer.write(output_buffer)
        output_buffer.seek(0)
        
        # Cleanup
        cleanup_file(input_path)
        
        output_filename = generate_unique_filename(file.filename, 'pdf')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        return jsonify({'error': f'Page deletion failed: {str(e)}'}), 500

@app.route('/api/lock-pdf', methods=['POST'])
def lock_pdf():
    """Add password protection to PDF"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    password = request.form.get('password', '').strip()
    
    if not allowed_file(file.filename, 'pdf'):
        return jsonify({'error': 'Invalid file type. Only PDF files are allowed.'}), 400
    
    if not password:
        return jsonify({'error': 'Password is required'}), 400
    
    # Validate password (basic validation)
    if len(password) < 4:
        return jsonify({'error': 'Password must be at least 4 characters'}), 400
    
    # Validate file size
    is_valid, error_msg = validate_file_size(file)
    if not is_valid:
        return jsonify({'error': error_msg}), 400
    
    try:
        # Save uploaded file
        input_filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], input_filename)
        file.save(input_path)
        
        reader = PdfReader(input_path)
        writer = PdfWriter()
        
        # Add all pages
        for page in reader.pages:
            writer.add_page(page)
        
        # Add password protection
        writer.encrypt(password)
        
        # Create output PDF
        output_buffer = io.BytesIO()
        writer.write(output_buffer)
        output_buffer.seek(0)
        
        # Cleanup
        cleanup_file(input_path)
        
        output_filename = generate_unique_filename(file.filename, 'pdf')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        return jsonify({'error': f'Lock failed: {str(e)}'}), 500

@app.route('/api/unlock-pdf', methods=['POST'])
def unlock_pdf():
    """Remove password protection from PDF"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    password = request.form.get('password', '').strip()
    
    if not allowed_file(file.filename, 'pdf'):
        return jsonify({'error': 'Invalid file type. Only PDF files are allowed.'}), 400
    
    if not password:
        return jsonify({'error': 'Password is required'}), 400
    
    # Validate file size
    is_valid, error_msg = validate_file_size(file)
    if not is_valid:
        return jsonify({'error': error_msg}), 400
    
    try:
        # Save uploaded file
        input_filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], input_filename)
        file.save(input_path)
        
        # Try to read with password
        reader = PdfReader(input_path)
        if reader.is_encrypted:
            success = reader.decrypt(password)
            if not success:
                cleanup_file(input_path)
                return jsonify({'error': 'Incorrect password'}), 401
        
        writer = PdfWriter()
        
        # Add all pages
        for page in reader.pages:
            writer.add_page(page)
        
        # Create unencrypted PDF
        output_buffer = io.BytesIO()
        writer.write(output_buffer)
        output_buffer.seek(0)
        
        # Cleanup
        cleanup_file(input_path)
        
        output_filename = generate_unique_filename(file.filename, 'pdf')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        return jsonify({'error': f'Unlock failed: {str(e)}'}), 500

# ==================== WORD TOOLS ====================

@app.route('/api/word-to-pdf', methods=['POST'])
def word_to_pdf():
    """Convert Word document to PDF"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    
    if not allowed_file(file.filename, 'word'):
        return jsonify({'error': 'Invalid file type. Only Word documents (.doc, .docx) are allowed.'}), 400
    
    # Validate file size
    is_valid, error_msg = validate_file_size(file)
    if not is_valid:
        return jsonify({'error': error_msg}), 400
    
    try:
        # Save uploaded file
        input_filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], input_filename)
        file.save(input_path)
        
        # Read Word document
        doc = Document(input_path)
        
        # Create PDF with better formatting
        output_buffer = io.BytesIO()
        doc_pdf = SimpleDocTemplate(output_buffer, pagesize=A4)
        
        # Define styles
        styles = getSampleStyleSheet()
        
        # Custom style for normal text
        normal_style = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontSize=11,
            leading=14,
            spaceAfter=6
        )
        
        # Custom style for headings
        heading_style = ParagraphStyle(
            'CustomHeading',
            parent=styles['Heading1'],
            fontSize=14,
            leading=18,
            spaceAfter=12,
            spaceBefore=12
        )
        
        # Build story (content)
        story = []
        
        for paragraph in doc.paragraphs:
            text = paragraph.text.strip()
            if not text:
                continue
                
            # Check if this looks like a heading (simple heuristic)
            if paragraph.style.name.startswith('Heading') or (len(text) < 100 and not text.endswith('.')):
                p = Paragraph(text, heading_style)
            else:
                p = Paragraph(text, normal_style)
            
            story.append(p)
            story.append(Spacer(1, 6))
        
        # Build PDF
        doc_pdf.build(story)
        output_buffer.seek(0)
        
        # Cleanup
        cleanup_file(input_path)
        
        output_filename = generate_unique_filename(file.filename, 'pdf')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        return jsonify({'error': f'Conversion failed: {str(e)}'}), 500

@app.route('/api/word-to-text', methods=['POST'])
def word_to_text():
    """Extract text from Word document"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    
    if not allowed_file(file.filename, 'word'):
        return jsonify({'error': 'Invalid file type. Only Word documents (.doc, .docx) are allowed.'}), 400
    
    # Validate file size
    is_valid, error_msg = validate_file_size(file)
    if not is_valid:
        return jsonify({'error': error_msg}), 400
    
    try:
        # Save uploaded file
        input_filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], input_filename)
        file.save(input_path)
        
        # Read Word document and extract text
        doc = Document(input_path)
        text_content = []
        
        for paragraph in doc.paragraphs:
            text = paragraph.text.strip()
            if text:
                text_content.append(text)
        
        full_text = '\n\n'.join(text_content)
        
        # Create text file
        output_buffer = io.BytesIO()
        output_buffer.write(full_text.encode('utf-8'))
        output_buffer.seek(0)
        
        # Cleanup
        cleanup_file(input_path)
        
        output_filename = generate_unique_filename(file.filename, 'txt')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='text/plain'
        )
        
    except Exception as e:
        return jsonify({'error': f'Text extraction failed: {str(e)}'}), 500

# ==================== TEXT TOOLS ====================

@app.route('/api/text-to-pdf', methods=['POST'])
def text_to_pdf():
    """Convert plain text to PDF"""
    text = request.form.get('text', '').strip()
    
    if not text:
        return jsonify({'error': 'No text provided'}), 400
    
    if len(text) > 1000000:  # ~1MB of text
        return jsonify({'error': 'Text is too long (maximum 1MB)'}), 400
    
    try:
        # Create PDF with proper formatting
        output_buffer = io.BytesIO()
        doc = SimpleDocTemplate(output_buffer, pagesize=A4)
        
        # Define styles
        styles = getSampleStyleSheet()
        normal_style = ParagraphStyle(
            'TextStyle',
            parent=styles['Normal'],
            fontSize=11,
            leading=14,
            spaceAfter=6
        )
        
        # Split text into paragraphs
        paragraphs = text.split('\n')
        story = []
        
        for para in paragraphs:
            para = para.strip()
            if para:
                story.append(Paragraph(para, normal_style))
                story.append(Spacer(1, 6))
        
        # Build PDF
        doc.build(story)
        output_buffer.seek(0)
        
        output_filename = generate_unique_filename("text", 'pdf')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        return jsonify({'error': f'PDF creation failed: {str(e)}'}), 500

@app.route('/api/text-to-word', methods=['POST'])
def text_to_word():
    """Convert plain text to Word document"""
    text = request.form.get('text', '').strip()
    
    if not text:
        return jsonify({'error': 'No text provided'}), 400
    
    if len(text) > 1000000:  # ~1MB of text
        return jsonify({'error': 'Text is too long (maximum 1MB)'}), 400
    
    try:
        # Create Word document
        doc = Document()
        
        # Add text paragraphs
        paragraphs = text.split('\n')
        for para in paragraphs:
            para = para.strip()
            if para:
                doc.add_paragraph(para)
        
        # Save to bytes buffer
        output_buffer = io.BytesIO()
        doc.save(output_buffer)
        output_buffer.seek(0)
        
        output_filename = generate_unique_filename("text", 'docx')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        )
        
    except Exception as e:
        return jsonify({'error': f'Word creation failed: {str(e)}'}), 500

# ==================== IMAGE TOOLS ====================

@app.route('/api/images-to-pdf', methods=['POST'])
def images_to_pdf():
    """Convert images to PDF"""
    if 'files' not in request.files:
        return jsonify({'error': 'No files uploaded'}), 400
    
    files = request.files.getlist('files')
    valid_files = [f for f in files if f.filename != '']
    
    if not valid_files:
        return jsonify({'error': 'No files selected'}), 400
    
    if len(valid_files) > 50:
        return jsonify({'error': 'Maximum 50 images allowed'}), 400
    
    try:
        # Create PDF with images
        output_buffer = io.BytesIO()
        c = canvas.Canvas(output_buffer, pagesize=A4)
        width, height = A4
        
        temp_files = []
        
        for i, file in enumerate(valid_files):
            if not allowed_file(file.filename, 'images'):
                # Cleanup temp files
                for temp_file in temp_files:
                    cleanup_file(temp_file)
                return jsonify({'error': 'Invalid file type. Only image files are allowed.'}), 400
            
            # Validate file size
            is_valid, error_msg = validate_file_size(file)
            if not is_valid:
                # Cleanup temp files
                for temp_file in temp_files:
                    cleanup_file(temp_file)
                return jsonify({'error': error_msg}), 400
            
            # Save image temporarily
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(filepath)
            temp_files.append(filepath)
            
            try:
                # Open and process image
                img = Image.open(filepath)
                
                # Convert to RGB if necessary
                if img.mode in ('RGBA', 'P', 'LA'):
                    rgb_img = Image.new('RGB', img.size, (255, 255, 255))
                    if img.mode == 'P':
                        img = img.convert('RGBA')
                    rgb_img.paste(img, mask=img.split()[3] if img.mode == 'RGBA' else None)
                    img = rgb_img
                elif img.mode != 'RGB':
                    img = img.convert('RGB')
                
                # Save as JPEG for PDF inclusion
                img_path_jpg = filepath + '.jpg'
                img.save(img_path_jpg, 'JPEG', quality=90)
                temp_files.append(img_path_jpg)
                
                # Add new page for each image (except first)
                if i > 0:
                    c.showPage()
                
                # Calculate image size to fit page with margins
                margin = 2 * cm
                max_width = width - 2 * margin
                max_height = height - 2 * margin
                
                img_width, img_height = img.size
                scale = min(max_width / img_width, max_height / img_height)
                new_width = img_width * scale
                new_height = img_height * scale
                
                # Center image on page
                x = (width - new_width) / 2
                y = (height - new_height) / 2
                
                # Draw image
                c.drawImage(img_path_jpg, x, y, new_width, new_height)
                
            except Exception as img_error:
                # Cleanup temp files
                for temp_file in temp_files:
                    cleanup_file(temp_file)
                return jsonify({'error': f'Error processing image {file.filename}: {str(img_error)}'}), 400
        
        c.save()
        output_buffer.seek(0)
        
        # Cleanup temporary files
        for filepath in temp_files:
            cleanup_file(filepath)
        
        output_filename = generate_unique_filename("images", 'pdf')
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name=output_filename,
            mimetype='application/pdf'
        )
        
    except Exception as e:
        # Cleanup temp files on error
        if 'temp_files' in locals():
            for filepath in temp_files:
                cleanup_file(filepath)
        return jsonify({'error': f'PDF creation failed: {str(e)}'}), 500

# ==================== HEALTH CHECK & INFO ====================

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'service': 'iMasterPDF',
        'version': '1.0.0'
    })

@app.route('/api/info', methods=['GET'])
def api_info():
    """API information"""
    return jsonify({
        'name': 'iMasterPDF API',
        'version': '1.0.0',
        'description': 'Free Online PDF & Document Tools',
        'limits': {
            'max_file_size': '50 MB',
            'max_files_merge': '20',
            'max_images_pdf': '50',
            'min_file_size': '1 KB'
        },
        'supported_formats': {
            'pdf': ['pdf'],
            'word': ['doc', 'docx'],
            'images': ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp']
        }
    })

# ==================== ERROR HANDLERS ====================

@app.errorhandler(404)
def not_found_error(error):
    return jsonify({'error': 'Endpoint not found'}), 404

@app.errorhandler(405)
def method_not_allowed_error(error):
    return jsonify({'error': 'Method not allowed'}), 405

@app.errorhandler(413)
def request_entity_too_large(error):
    return jsonify({'error': 'File too large (maximum 50 MB)'}), 413

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500

# ==================== MAIN APPLICATION ====================

if __name__ == '__main__':
    # Create upload folder if it doesn't exist
    upload_folder = Path(app.config['UPLOAD_FOLDER'])
    upload_folder.mkdir(exist_ok=True)
    
    # Run the application
    print("Starting iMasterPDF server...")
    print(f"Upload folder: {app.config['UPLOAD_FOLDER']}")
    print(f"Max file size: {app.config['MAX_CONTENT_LENGTH'] / (1024*1024)} MB")
    
    # For production use: app.run(host='0.0.0.0', port=5000)
    # For development:
    app.run(debug=True, host='0.0.0.0', port=5000)